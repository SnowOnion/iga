<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>åšä¸½çµæ¢¦å¤§æˆ˜</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.1.0/style.css" />
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            touch-action: none;
            font-family: "LXGW WenKai Screen", -apple-system, sans-serif;
            position: fixed;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameContainer {
            position: relative;
            width: 100vmin;
            height: 200vmin;
            max-width: 500px;
            max-height: 1000px;
        }

        #gameCanvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: #000;
            border: 1px solid #333;
        }

        #gameInfo {
            position: absolute;
            right: 10px;
            top: 10px;
            color: #fff;
            font-size: 18px;
            text-align: right;
            z-index: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #score, #powerLevel {
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #333;
            border-radius: 5px;
        }

        #startMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        #difficulty {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            text-align: center;
            display: none;
            flex-direction: column;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            text-align: center;
            display: none;
            flex-direction: column;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .difficulty-btn, #restartBtn {
            background: #333;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            font-family: inherit;
            transition: background 0.2s;
        }

        .difficulty-btn:hover, #restartBtn:hover {
            background: #666;
        }

        .dementor {
            position: absolute;
            pointer-events: none;
            z-index: 1;
            transform: translate(-50%, -50%);
        }

        #version {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: #666;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="gameInfo">
            <div id="score">åˆ†æ•°: 0</div>
            <div id="powerLevel">ç«åŠ›: 0</div>
        </div>
        <div id="startMessage">
            ç‚¹å‡»å±å¹•å¼€å§‹æ¸¸æˆ<br>
            ç§»åŠ¨æ‰‹æŒ‡æ§åˆ¶çµæ¢¦<br>
            å¾¡æœ­ä¼šè‡ªåŠ¨å‘å°„
        </div>
        <div id="difficulty">
            é€‰æ‹©éš¾åº¦ï¼š<br>
            <button class="difficulty-btn" data-difficulty="1">ç®€å•</button>
            <button class="difficulty-btn" data-difficulty="2">ä¸­ç­‰</button>
            <button class="difficulty-btn" data-difficulty="3">å›°éš¾</button>
        </div>
        <div id="gameOver">
            æ¸¸æˆç»“æŸ<br>
            æœ€ç»ˆåˆ†æ•°: <span id="finalScore">0</span><br>
            <button id="restartBtn">é‡æ–°å¼€å§‹</button>
        </div>
    </div>
    <div id="version">v0.1.8</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startMessage = document.getElementById('startMessage');
        const scoreElement = document.getElementById('score');
        const powerLevelElement = document.getElementById('powerLevel');
        const finalScoreElement = document.getElementById('finalScore');

        let isGameOver = false;
        let gameStarted = false;
        let score = 0;
        let lastSpawnTime = 0;
        let lastShootTime = 0;
        let spawnInterval = 1000;  // é»˜è®¤ç”Ÿæˆé—´éš”
        let lastFrameTime = 0;     // ç”¨äºè®¡ç®—å¸§é—´æ—¶é—´
        let animationFrameId = null;  // ç”¨äºå­˜å‚¨ requestAnimationFrame çš„ ID

        // æ¸¸æˆå¯¹è±¡
        let player = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            size: 40,
            power: 0
        };

        let dementors = [];
        let spells = [];
        let powerUps = [];

        const GAME_WIDTH = 400;
        const GAME_HEIGHT = Math.min(window.innerHeight, 800);

        function resizeCanvas() {
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            
            // æ›´æ–°ç©å®¶ä½ç½®ï¼Œä½†ä¿æŒåœ¨æ°´å¹³æ–¹å‘çš„ç›¸å¯¹ä½ç½®
            const playerXRatio = player.x / GAME_WIDTH;
            player.x = GAME_WIDTH * playerXRatio;
            player.y = GAME_HEIGHT - 100;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function spawnDementor() {
            const size = 40;
            const patterns = [
                // ç›´çº¿ä¸‹è½+å°å¹…æ‘†åŠ¨
                {
                    speed: 2 + Math.random(),
                    angle: Math.random() * Math.PI * 2,
                    angleSpeed: (Math.random() - 0.5) * 0.08,
                    amplitude: 10 + Math.random() * 15,
                    pattern: 'swing',
                    emoji: 'ğŸ‘¿'  // æ‘†åŠ¨çš„æ¶é­”
                },
                // èºæ—‹ä¸‹é™
                {
                    speed: 1.5 + Math.random(),
                    angle: Math.random() * Math.PI * 2,
                    angleSpeed: (Math.random() < 0.5 ? 0.05 : -0.05),
                    radius: 50 + Math.random() * 50,
                    pattern: 'spiral',
                    emoji: 'ğŸ’€'  // æ—‹è½¬çš„éª·é«…
                },
                // Zå­—å½¢
                {
                    speed: 1.8 + Math.random(),
                    direction: Math.random() < 0.5 ? 1 : -1,
                    switchTime: Date.now(),
                    switchInterval: 1000 + Math.random() * 1000,
                    amplitude: 20 + Math.random() * 20,
                    pattern: 'zigzag',
                    emoji: 'ğŸ‘¾'  // Zå­—å½¢ç§»åŠ¨çš„å¤–æ˜Ÿäºº
                }
            ];

            const pattern = patterns[Math.floor(Math.random() * patterns.length)];
            const x = Math.random() * (canvas.width - size);

            dementors.push({
                x: x,
                y: -size,
                size: size,
                health: 3,
                maxHealth: 3,
                initialX: x,
                ...pattern
            });
        }

        // æ·»åŠ ä¸€ä¸ªå®¹å™¨æ¥ç®¡ç†æ‰€æœ‰æ€ªç‰©å…ƒç´ 
        const dementorContainer = document.createElement('div');
        dementorContainer.style.position = 'fixed';
        dementorContainer.style.left = '0';
        dementorContainer.style.top = '0';
        dementorContainer.style.width = '100%';
        dementorContainer.style.height = '100%';
        dementorContainer.style.pointerEvents = 'none';
        document.body.appendChild(dementorContainer);

        let dementorElements = new Set();

        function clearDementors() {
            // æ¸…é™¤æ‰€æœ‰ dementor å…ƒç´ 
            dementorElements.forEach(el => el.remove());
            dementorElements.clear();
        }

        function getCanvasPosition(x, y) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: rect.left + (x / scaleX),
                y: rect.top + (y / scaleY)
            };
        }

        function drawDementor(x, y, size, health, emoji) {
            // ç»˜åˆ¶ç”Ÿå‘½å€¼æ¡
            ctx.save();
            ctx.fillStyle = '#600';
            const healthBarWidth = size;
            const healthBarHeight = 4;
            ctx.fillRect(x - healthBarWidth/2, y - size/2 - 10, healthBarWidth * health / 3, healthBarHeight);
            ctx.restore();

            // ç»˜åˆ¶æ€ªç‰©
            const dementor = document.createElement('div');
            dementor.className = 'dementor';
            dementor.style.left = x + 'px';
            dementor.style.top = y + 'px';
            dementor.style.fontSize = size + 'px';
            dementor.textContent = emoji;
            document.body.appendChild(dementor);
            dementorElements.add(dementor);
            
            // æ˜¾ç¤ºç¢°æ’åŒºåŸŸ
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(x, y, size/2.5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        function checkCollision(x1, y1, x2, y2, distance) {
            if (arguments.length === 5) {
                // ä¸»è§’çš„ç¢°æ’æ£€æµ‹ï¼ˆä¿æŒå°èŒƒå›´ï¼‰
                const actualDistance = distance / 3;
                return Math.hypot(x1 - x2, y1 - y2) < actualDistance;
            } else {
                // æ€ªç‰©çš„ç¢°æ’æ£€æµ‹ï¼ˆä¸æ˜¾ç¤ºå¤§å°æ¥è¿‘ï¼‰
                const obj1 = arguments[0];
                const obj2 = arguments[1];
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                return Math.hypot(dx, dy) < obj1.size/2.5;
            }
        }

        function drawWizard(x, y, size, castingSpell) {
            ctx.save();
            
            // ç»˜åˆ¶çº¢ç™½è´è¶ç»“ï¼ˆç§»åˆ°å¤´ä¸Šï¼‰
            const bowSize = size/4;
            // çº¢è‰²éƒ¨åˆ†
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.ellipse(x - bowSize/2, y - size*0.8, bowSize/2, bowSize/4, Math.PI/4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + bowSize/2, y - size*0.8, bowSize/2, bowSize/4, -Math.PI/4, 0, Math.PI * 2);
            ctx.fill();
            // ç™½è‰²ä¸­å¿ƒ
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x, y - size*0.8, bowSize/4, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶è£™å­ï¼ˆçº¢è‰²ï¼‰
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.moveTo(x, y - size/2);
            ctx.lineTo(x - size/2, y + size/2);
            ctx.lineTo(x + size/2, y + size/2);
            ctx.closePath();
            ctx.fill();

            // ç»˜åˆ¶ç™½è‰²å›´è£™
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(x, y - size/3);
            ctx.lineTo(x - size/3, y + size/3);
            ctx.lineTo(x + size/3, y + size/3);
            ctx.closePath();
            ctx.fill();

            // ç»˜åˆ¶å¤´éƒ¨ï¼ˆç™½è‰²ï¼‰
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x, y - size/2, size/3, 0, Math.PI * 2);
            ctx.fill();

            // ç»˜åˆ¶é»‘è‰²é•¿å‘
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y - size/2, size/3 + 2, Math.PI * 0.2, Math.PI * 0.8, true);
            ctx.fill();

            // ç»˜åˆ¶è¢–å­
            ctx.fillStyle = '#f00';
            // å·¦è¢–
            ctx.beginPath();
            ctx.ellipse(x - size/2, y, size/4, size/6, Math.PI/4, 0, Math.PI * 2);
            ctx.fill();
            // å³è¢–
            ctx.beginPath();
            ctx.ellipse(x + size/2, y, size/4, size/6, -Math.PI/4, 0, Math.PI * 2);
            ctx.fill();

            // å¦‚æœéœ€è¦è°ƒè¯•ç¢°æ’åŒºåŸŸï¼Œå–æ¶ˆä¸‹é¢çš„æ³¨é‡Š
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(x, y, size/6, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }

        function castSpell() {
            const now = Date.now();
            const shootInterval = Math.max(100, 400 - player.power * 30);
            if (now - lastShootTime >= shootInterval) {
                const spellSize = 10;
                spells.push({
                    x: player.x,
                    y: player.y - player.size / 2,
                    size: spellSize,
                    speed: 10
                });
                lastShootTime = now;
            }
        }

        function updateSpells() {
            for (let i = spells.length - 1; i >= 0; i--) {
                const spell = spells[i];
                spell.y -= spell.speed;
                if (spell.y < 0) {
                    spells.splice(i, 1);
                }
            }
        }

        function drawSpells() {
            spells.forEach(spell => {
                ctx.save();
                
                // è®¡ç®—æ—‹è½¬è§’åº¦
                spell.rotation = (spell.rotation || 0) + 0.1;
                
                // ç§»åŠ¨åˆ°å­å¼¹ä½ç½®å¹¶æ—‹è½¬
                ctx.translate(spell.x, spell.y);
                ctx.rotate(spell.rotation);
                
                // ç»˜åˆ¶æ–¹å—
                const size = spell.size * 1.5;
                ctx.fillStyle = 'rgba(255, 200, 200, 0.7)';  // æ·¡çº¢è‰²
                ctx.fillRect(-size/2, -size/2, size, size);
                
                // ç»˜åˆ¶å†…éƒ¨ç™½è‰²æ–¹å—
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';  // åŠé€æ˜ç™½è‰²
                const innerSize = size * 0.6;
                ctx.fillRect(-innerSize/2, -innerSize/2, innerSize, innerSize);
                
                ctx.restore();
            });
        }

        function updatePowerUps() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.y += powerUp.speed;

                // æ£€æŸ¥æ˜¯å¦è¢«æ”¶é›†
                if (checkPowerUpCollision(powerUp, player)) {
                    player.power++;
                    updatePowerLevel();
                    powerUps.splice(i, 1);
                    continue;
                }

                // æ£€æŸ¥æ˜¯å¦è¶…å‡ºå±å¹•
                if (powerUp.y > canvas.height) {
                    powerUps.splice(i, 1);
                }
            }
        }

        function drawPowerUps() {
            powerUps.forEach(powerUp => {
                drawPowerUp(powerUp);
            });
        }

        function drawPowerUp(powerUp) {
            const pos = getCanvasPosition(powerUp.x, powerUp.y);
            const scaledSize = powerUp.size * (canvas.getBoundingClientRect().width / canvas.width);

            // è·å–æˆ–åˆ›å»º powerUp å…ƒç´ 
            let powerUpEl = document.getElementById(`powerup-${powerUp.x}-${powerUp.y}`);
            if (!powerUpEl) {
                powerUpEl = document.createElement('div');
                powerUpEl.id = `powerup-${powerUp.x}-${powerUp.y}`;
                powerUpEl.className = 'dementor';  // å¤ç”¨ dementor çš„æ ·å¼
                dementorContainer.appendChild(powerUpEl);
            }

            // æ›´æ–°ä½ç½®å’Œæ ·å¼
            powerUpEl.style.left = pos.x + 'px';
            powerUpEl.style.top = pos.y + 'px';
            powerUpEl.style.fontSize = scaledSize + 'px';
            powerUpEl.textContent = powerUp.emoji;
        }

        function checkPowerUpCollision(powerUp, player) {
            const dx = powerUp.x - player.x;
            const dy = powerUp.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (powerUp.size + player.size) / 2;
        }

        function updatePowerLevel() {
            powerLevelElement.textContent = `ç«åŠ›: ${player.power}`;
        }

        function gameLoop(currentTime) {
            if (!isGameOver) {
                // è®¡ç®—å¸§é—´æ—¶é—´ï¼ˆç§’ï¼‰
                const deltaTime = lastFrameTime ? (currentTime - lastFrameTime) / 1000 : 0;
                lastFrameTime = currentTime;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                clearDementors();  // åœ¨æ¯ä¸€å¸§å¼€å§‹æ—¶æ¸…é™¤æ‰€æœ‰æ€ªç‰©å…ƒç´ 

                if (gameStarted) {
                    castSpell();

                    // æ›´æ–°å’Œç»˜åˆ¶æ‰€æœ‰æ¸¸æˆå¯¹è±¡
                    updateSpells();
                    updatePowerUps();
                    drawSpells();
                    drawPowerUps();

                    // æ›´æ–°å’Œç»˜åˆ¶æ‘„é­‚æ€ª
                    for (let i = dementors.length - 1; i >= 0; i--) {
                        const dementor = dementors[i];

                        // æ ¹æ®ä¸åŒæ¨¡å¼æ›´æ–°ä½ç½®ï¼Œä½¿ç”¨ deltaTime ä½¿ç§»åŠ¨é€Ÿåº¦ç‹¬ç«‹äºå¸§ç‡
                        switch (dementor.pattern) {
                            case 'swing':
                                dementor.angle += dementor.angleSpeed * deltaTime;
                                dementor.y += dementor.speed * deltaTime * 60;  // ä¹˜ä»¥ 60 ä½¿é€Ÿåº¦ä¸ä¹‹å‰å¤§è‡´ç›¸åŒ
                                dementor.x += Math.sin(dementor.angle) * dementor.amplitude * 0.1 * deltaTime * 60;
                                break;

                            case 'spiral':
                                dementor.angle += dementor.angleSpeed * deltaTime;
                                dementor.y += dementor.speed * deltaTime * 60;
                                dementor.x = dementor.initialX + Math.cos(dementor.angle) * dementor.radius;
                                break;

                            case 'zigzag':
                                dementor.y += dementor.speed * deltaTime * 60;

                                if (Date.now() - dementor.switchTime > dementor.switchInterval) {
                                    dementor.direction *= -1;
                                    dementor.switchTime = Date.now();
                                }
                                dementor.x += dementor.direction * dementor.amplitude * 0.1 * deltaTime * 60;
                                break;
                        }

                        // ç¡®ä¿æ‘„é­‚æ€ªä¸ä¼šå®Œå…¨ç¦»å¼€å±å¹•
                        dementor.x = Math.max(dementor.size / 2, Math.min(canvas.width - dementor.size / 2, dementor.x));

                        // æ£€æŸ¥æ˜¯å¦è¢«å‡»ä¸­
                        for (let j = spells.length - 1; j >= 0; j--) {
                            const spell = spells[j];
                            if (checkCollision(dementor, spell)) {
                                dementor.health--;
                                spells.splice(j, 1);

                                if (dementor.health <= 0) {
                                    dementors.splice(i, 1);
                                    score += 100;
                                    document.getElementById('score').textContent = 'åˆ†æ•°: ' + score;
                                    break;
                                }
                            }
                        }

                        drawDementor(dementor.x, dementor.y, dementor.size, dementor.health, dementor.emoji);

                        // æ£€æŸ¥ä¸ç©å®¶ç¢°æ’
                        if (checkCollision(dementor.x, dementor.y, player.x, player.y, dementor.size)) {
                            gameOver();
                            return;
                        }

                        // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾åº•éƒ¨
                        if (dementor.y > canvas.height + dementor.size) {
                            dementors.splice(i, 1);
                        }
                    }
                }

                drawWizard(player.x, player.y, player.size, Date.now() - lastShootTime < 100);
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        function startGame() {
            gameStarted = true;
            isGameOver = false;
            score = 0;
            document.getElementById('score').textContent = 'åˆ†æ•°: 0';
            startMessage.style.display = 'none';
            document.getElementById('difficulty').style.display = 'none';
            dementors = [];
            spells = [];
            powerUps = [];
            // æ¸…é™¤æ‰€æœ‰æ€ªç‰©å…ƒç´ 
            clearDementors();
            player = {
                x: canvas.width / 2,
                y: canvas.height - 100,
                size: 40,
                power: 0
            };
            updatePowerLevel();
            lastSpawnTime = Date.now();
            lastShootTime = Date.now();
            lastFrameTime = 0;  // é‡ç½®å¸§æ—¶é—´
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);  // å–æ¶ˆä¹‹å‰çš„åŠ¨ç”»å¸§
            }
            gameLoop();  // å¼€å§‹æ–°çš„æ¸¸æˆå¾ªç¯
            startDementorSpawn();
        }

        function gameOver() {
            isGameOver = true;
            gameStarted = false;
            finalScoreElement.textContent = score;
            document.getElementById('gameOver').style.display = 'flex';
            document.getElementById('difficulty').style.display = 'none';
            // æ¸…é™¤æ€ªç‰©ç”Ÿæˆå®šæ—¶å™¨
            if (window.spawnInterval) {
                clearInterval(window.spawnInterval);
            }
            // æ¸…é™¤æ‰€æœ‰æ€ªç‰©å…ƒç´ 
            clearDementors();
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);  // å–æ¶ˆåŠ¨ç”»å¸§
            }
        }

        function restart() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('difficulty').style.display = 'flex';
            // æ¸…é™¤æ‰€æœ‰æ€ªç‰©å…ƒç´ 
            clearDementors();
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);  // å–æ¶ˆåŠ¨ç”»å¸§
            }
            lastFrameTime = 0;  // é‡ç½®å¸§æ—¶é—´
        }

        function startDementorSpawn() {
            // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„æ—§å®šæ—¶å™¨
            if (window.spawnInterval) {
                clearInterval(window.spawnInterval);
            }
            
            // è®¾ç½®æ–°çš„å®šæ—¶å™¨
            window.spawnInterval = setInterval(() => {
                if (!isGameOver && gameStarted) {
                    // æ ¹æ®éš¾åº¦ç”Ÿæˆæ€ªç‰©
                    for (let i = 0; i < 2; i++) {
                        spawnDementor();
                    }
                }
            }, 1000); // æ¯ç§’ç”Ÿæˆä¸€æ³¢
        }

        function getCanvasX(screenX) {
            const rect = canvas.getBoundingClientRect();
            const scale = GAME_WIDTH / rect.width;
            return (screenX - rect.left) * scale;
        }

        function handleMove(screenX) {
            if (!isGameOver && gameStarted) {
                const canvasX = getCanvasX(screenX);
                player.x = Math.max(player.size / 2, Math.min(GAME_WIDTH - player.size / 2, canvasX));
            }
        }

        // è§¦æ‘¸äº‹ä»¶å¤„ç†
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameStarted) {
                document.getElementById('difficulty').style.display = 'flex';
                startMessage.style.display = 'none';
            }
            const touch = e.touches[0];
            handleMove(touch.clientX);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleMove(touch.clientX);
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
        }, { passive: false });

        // é¼ æ ‡äº‹ä»¶å¤„ç†
        canvas.addEventListener('mousemove', (e) => {
            if (!isGameOver && gameStarted) {
                handleMove(e.clientX);
            }
        });

        canvas.addEventListener('click', (e) => {
            if (!gameStarted) {
                document.getElementById('difficulty').style.display = 'flex';
                startMessage.style.display = 'none';
            }
        });

        // æ·»åŠ éš¾åº¦é€‰æ‹©æŒ‰é’®çš„äº‹ä»¶ç›‘å¬
        document.querySelectorAll('.difficulty-btn').forEach(button => {
            button.addEventListener('click', () => {
                startGame();
            });
        });

        restartBtn.addEventListener('click', restart);

        function spawnPowerUp(x, y) {
            powerUps.push({
                x: x,
                y: y,
                size: 20,
                speed: 5,
                emoji: 'âš¡'  // é—ªç”µè¡¨ç¤ºç«åŠ›é“å…·
            });
        }

        gameLoop();
    </script>
</body>

</html>