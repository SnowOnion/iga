<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>博丽灵梦大战</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.1.0/style.css" />
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            touch-action: none;
            font-family: "LXGW WenKai Screen", -apple-system, sans-serif;
            position: fixed;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameContainer {
            position: relative;
            width: 100vmin;
            height: 200vmin;
            max-width: 500px;
            max-height: 1000px;
        }

        #gameCanvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: #000;
            border: 1px solid #333;
        }

        #gameInfo {
            position: absolute;
            right: 10px;
            top: 10px;
            color: #fff;
            font-size: 18px;
            text-align: right;
            z-index: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #score, #powerLevel {
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #333;
            border-radius: 5px;
        }

        #startMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        #difficulty {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            text-align: center;
            display: none;
            flex-direction: column;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            text-align: center;
            display: none;
            flex-direction: column;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .difficulty-btn, #restartBtn {
            background: #333;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            font-family: inherit;
            transition: background 0.2s;
        }

        .difficulty-btn:hover, #restartBtn:hover {
            background: #666;
        }

        .dementor {
            position: absolute;
            pointer-events: none;
            z-index: 1;
            transform: translate(-50%, -50%);
        }

        #version {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: #666;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="gameInfo">
            <div id="score">分数: 0</div>
            <div id="powerLevel">火力: 0</div>
        </div>
        <div id="startMessage">
            点击屏幕开始游戏<br>
            移动手指控制灵梦<br>
            御札会自动发射
        </div>
        <div id="difficulty">
            选择难度：<br>
            <button class="difficulty-btn" data-difficulty="1">简单</button>
            <button class="difficulty-btn" data-difficulty="2">中等</button>
            <button class="difficulty-btn" data-difficulty="3">困难</button>
        </div>
        <div id="gameOver">
            游戏结束<br>
            最终分数: <span id="finalScore">0</span><br>
            <button id="restartBtn">重新开始</button>
        </div>
    </div>
    <div id="version">v0.1.8</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startMessage = document.getElementById('startMessage');
        const scoreElement = document.getElementById('score');
        const powerLevelElement = document.getElementById('powerLevel');
        const finalScoreElement = document.getElementById('finalScore');

        let isGameOver = false;
        let gameStarted = false;
        let score = 0;
        let lastSpawnTime = 0;
        let lastShootTime = 0;
        let spawnInterval = 1000;  // 默认生成间隔
        let lastFrameTime = 0;     // 用于计算帧间时间
        let animationFrameId = null;  // 用于存储 requestAnimationFrame 的 ID

        // 游戏对象
        let player = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            size: 40,
            power: 0
        };

        let dementors = [];
        let spells = [];
        let powerUps = [];

        const GAME_WIDTH = 400;
        const GAME_HEIGHT = Math.min(window.innerHeight, 800);

        function resizeCanvas() {
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            
            // 更新玩家位置，但保持在水平方向的相对位置
            const playerXRatio = player.x / GAME_WIDTH;
            player.x = GAME_WIDTH * playerXRatio;
            player.y = GAME_HEIGHT - 100;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function spawnDementor() {
            const size = 40;
            const patterns = [
                // 直线下落+小幅摆动
                {
                    speed: 2 + Math.random(),
                    angle: Math.random() * Math.PI * 2,
                    angleSpeed: (Math.random() - 0.5) * 0.08,
                    amplitude: 10 + Math.random() * 15,
                    pattern: 'swing',
                    emoji: '👿'  // 摆动的恶魔
                },
                // 螺旋下降
                {
                    speed: 1.5 + Math.random(),
                    angle: Math.random() * Math.PI * 2,
                    angleSpeed: (Math.random() < 0.5 ? 0.05 : -0.05),
                    radius: 50 + Math.random() * 50,
                    pattern: 'spiral',
                    emoji: '💀'  // 旋转的骷髅
                },
                // Z字形
                {
                    speed: 1.8 + Math.random(),
                    direction: Math.random() < 0.5 ? 1 : -1,
                    switchTime: Date.now(),
                    switchInterval: 1000 + Math.random() * 1000,
                    amplitude: 20 + Math.random() * 20,
                    pattern: 'zigzag',
                    emoji: '👾'  // Z字形移动的外星人
                }
            ];

            const pattern = patterns[Math.floor(Math.random() * patterns.length)];
            const x = Math.random() * (canvas.width - size);

            dementors.push({
                x: x,
                y: -size,
                size: size,
                health: 3,
                maxHealth: 3,
                initialX: x,
                ...pattern
            });
        }

        // 添加一个容器来管理所有怪物元素
        const dementorContainer = document.createElement('div');
        dementorContainer.style.position = 'fixed';
        dementorContainer.style.left = '0';
        dementorContainer.style.top = '0';
        dementorContainer.style.width = '100%';
        dementorContainer.style.height = '100%';
        dementorContainer.style.pointerEvents = 'none';
        document.body.appendChild(dementorContainer);

        let dementorElements = new Set();

        function clearDementors() {
            // 清除所有 dementor 元素
            dementorElements.forEach(el => el.remove());
            dementorElements.clear();
        }

        function getCanvasPosition(x, y) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: rect.left + (x / scaleX),
                y: rect.top + (y / scaleY)
            };
        }

        function drawDementor(x, y, size, health, emoji) {
            // 绘制生命值条
            ctx.save();
            ctx.fillStyle = '#600';
            const healthBarWidth = size;
            const healthBarHeight = 4;
            ctx.fillRect(x - healthBarWidth/2, y - size/2 - 10, healthBarWidth * health / 3, healthBarHeight);
            ctx.restore();

            // 绘制怪物
            const dementor = document.createElement('div');
            dementor.className = 'dementor';
            dementor.style.left = x + 'px';
            dementor.style.top = y + 'px';
            dementor.style.fontSize = size + 'px';
            dementor.textContent = emoji;
            document.body.appendChild(dementor);
            dementorElements.add(dementor);
            
            // 显示碰撞区域
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(x, y, size/2.5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        function checkCollision(x1, y1, x2, y2, distance) {
            if (arguments.length === 5) {
                // 主角的碰撞检测（保持小范围）
                const actualDistance = distance / 3;
                return Math.hypot(x1 - x2, y1 - y2) < actualDistance;
            } else {
                // 怪物的碰撞检测（与显示大小接近）
                const obj1 = arguments[0];
                const obj2 = arguments[1];
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                return Math.hypot(dx, dy) < obj1.size/2.5;
            }
        }

        function drawWizard(x, y, size, castingSpell) {
            ctx.save();
            
            // 绘制红白蝴蝶结（移到头上）
            const bowSize = size/4;
            // 红色部分
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.ellipse(x - bowSize/2, y - size*0.8, bowSize/2, bowSize/4, Math.PI/4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + bowSize/2, y - size*0.8, bowSize/2, bowSize/4, -Math.PI/4, 0, Math.PI * 2);
            ctx.fill();
            // 白色中心
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x, y - size*0.8, bowSize/4, 0, Math.PI * 2);
            ctx.fill();
            
            // 绘制裙子（红色）
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.moveTo(x, y - size/2);
            ctx.lineTo(x - size/2, y + size/2);
            ctx.lineTo(x + size/2, y + size/2);
            ctx.closePath();
            ctx.fill();

            // 绘制白色围裙
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(x, y - size/3);
            ctx.lineTo(x - size/3, y + size/3);
            ctx.lineTo(x + size/3, y + size/3);
            ctx.closePath();
            ctx.fill();

            // 绘制头部（白色）
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x, y - size/2, size/3, 0, Math.PI * 2);
            ctx.fill();

            // 绘制黑色长发
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y - size/2, size/3 + 2, Math.PI * 0.2, Math.PI * 0.8, true);
            ctx.fill();

            // 绘制袖子
            ctx.fillStyle = '#f00';
            // 左袖
            ctx.beginPath();
            ctx.ellipse(x - size/2, y, size/4, size/6, Math.PI/4, 0, Math.PI * 2);
            ctx.fill();
            // 右袖
            ctx.beginPath();
            ctx.ellipse(x + size/2, y, size/4, size/6, -Math.PI/4, 0, Math.PI * 2);
            ctx.fill();

            // 如果需要调试碰撞区域，取消下面的注释
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(x, y, size/6, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }

        function castSpell() {
            const now = Date.now();
            const shootInterval = Math.max(100, 400 - player.power * 30);
            if (now - lastShootTime >= shootInterval) {
                const spellSize = 10;
                spells.push({
                    x: player.x,
                    y: player.y - player.size / 2,
                    size: spellSize,
                    speed: 10
                });
                lastShootTime = now;
            }
        }

        function updateSpells() {
            for (let i = spells.length - 1; i >= 0; i--) {
                const spell = spells[i];
                spell.y -= spell.speed;
                if (spell.y < 0) {
                    spells.splice(i, 1);
                }
            }
        }

        function drawSpells() {
            spells.forEach(spell => {
                ctx.save();
                
                // 计算旋转角度
                spell.rotation = (spell.rotation || 0) + 0.1;
                
                // 移动到子弹位置并旋转
                ctx.translate(spell.x, spell.y);
                ctx.rotate(spell.rotation);
                
                // 绘制方块
                const size = spell.size * 1.5;
                ctx.fillStyle = 'rgba(255, 200, 200, 0.7)';  // 淡红色
                ctx.fillRect(-size/2, -size/2, size, size);
                
                // 绘制内部白色方块
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';  // 半透明白色
                const innerSize = size * 0.6;
                ctx.fillRect(-innerSize/2, -innerSize/2, innerSize, innerSize);
                
                ctx.restore();
            });
        }

        function updatePowerUps() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.y += powerUp.speed;

                // 检查是否被收集
                if (checkPowerUpCollision(powerUp, player)) {
                    player.power++;
                    updatePowerLevel();
                    powerUps.splice(i, 1);
                    continue;
                }

                // 检查是否超出屏幕
                if (powerUp.y > canvas.height) {
                    powerUps.splice(i, 1);
                }
            }
        }

        function drawPowerUps() {
            powerUps.forEach(powerUp => {
                drawPowerUp(powerUp);
            });
        }

        function drawPowerUp(powerUp) {
            const pos = getCanvasPosition(powerUp.x, powerUp.y);
            const scaledSize = powerUp.size * (canvas.getBoundingClientRect().width / canvas.width);

            // 获取或创建 powerUp 元素
            let powerUpEl = document.getElementById(`powerup-${powerUp.x}-${powerUp.y}`);
            if (!powerUpEl) {
                powerUpEl = document.createElement('div');
                powerUpEl.id = `powerup-${powerUp.x}-${powerUp.y}`;
                powerUpEl.className = 'dementor';  // 复用 dementor 的样式
                dementorContainer.appendChild(powerUpEl);
            }

            // 更新位置和样式
            powerUpEl.style.left = pos.x + 'px';
            powerUpEl.style.top = pos.y + 'px';
            powerUpEl.style.fontSize = scaledSize + 'px';
            powerUpEl.textContent = powerUp.emoji;
        }

        function checkPowerUpCollision(powerUp, player) {
            const dx = powerUp.x - player.x;
            const dy = powerUp.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (powerUp.size + player.size) / 2;
        }

        function updatePowerLevel() {
            powerLevelElement.textContent = `火力: ${player.power}`;
        }

        function gameLoop(currentTime) {
            if (!isGameOver) {
                // 计算帧间时间（秒）
                const deltaTime = lastFrameTime ? (currentTime - lastFrameTime) / 1000 : 0;
                lastFrameTime = currentTime;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                clearDementors();  // 在每一帧开始时清除所有怪物元素

                if (gameStarted) {
                    castSpell();

                    // 更新和绘制所有游戏对象
                    updateSpells();
                    updatePowerUps();
                    drawSpells();
                    drawPowerUps();

                    // 更新和绘制摄魂怪
                    for (let i = dementors.length - 1; i >= 0; i--) {
                        const dementor = dementors[i];

                        // 根据不同模式更新位置，使用 deltaTime 使移动速度独立于帧率
                        switch (dementor.pattern) {
                            case 'swing':
                                dementor.angle += dementor.angleSpeed * deltaTime;
                                dementor.y += dementor.speed * deltaTime * 60;  // 乘以 60 使速度与之前大致相同
                                dementor.x += Math.sin(dementor.angle) * dementor.amplitude * 0.1 * deltaTime * 60;
                                break;

                            case 'spiral':
                                dementor.angle += dementor.angleSpeed * deltaTime;
                                dementor.y += dementor.speed * deltaTime * 60;
                                dementor.x = dementor.initialX + Math.cos(dementor.angle) * dementor.radius;
                                break;

                            case 'zigzag':
                                dementor.y += dementor.speed * deltaTime * 60;

                                if (Date.now() - dementor.switchTime > dementor.switchInterval) {
                                    dementor.direction *= -1;
                                    dementor.switchTime = Date.now();
                                }
                                dementor.x += dementor.direction * dementor.amplitude * 0.1 * deltaTime * 60;
                                break;
                        }

                        // 确保摄魂怪不会完全离开屏幕
                        dementor.x = Math.max(dementor.size / 2, Math.min(canvas.width - dementor.size / 2, dementor.x));

                        // 检查是否被击中
                        for (let j = spells.length - 1; j >= 0; j--) {
                            const spell = spells[j];
                            if (checkCollision(dementor, spell)) {
                                dementor.health--;
                                spells.splice(j, 1);

                                if (dementor.health <= 0) {
                                    dementors.splice(i, 1);
                                    score += 100;
                                    document.getElementById('score').textContent = '分数: ' + score;
                                    break;
                                }
                            }
                        }

                        drawDementor(dementor.x, dementor.y, dementor.size, dementor.health, dementor.emoji);

                        // 检查与玩家碰撞
                        if (checkCollision(dementor.x, dementor.y, player.x, player.y, dementor.size)) {
                            gameOver();
                            return;
                        }

                        // 检查是否到达底部
                        if (dementor.y > canvas.height + dementor.size) {
                            dementors.splice(i, 1);
                        }
                    }
                }

                drawWizard(player.x, player.y, player.size, Date.now() - lastShootTime < 100);
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        function startGame() {
            gameStarted = true;
            isGameOver = false;
            score = 0;
            document.getElementById('score').textContent = '分数: 0';
            startMessage.style.display = 'none';
            document.getElementById('difficulty').style.display = 'none';
            dementors = [];
            spells = [];
            powerUps = [];
            // 清除所有怪物元素
            clearDementors();
            player = {
                x: canvas.width / 2,
                y: canvas.height - 100,
                size: 40,
                power: 0
            };
            updatePowerLevel();
            lastSpawnTime = Date.now();
            lastShootTime = Date.now();
            lastFrameTime = 0;  // 重置帧时间
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);  // 取消之前的动画帧
            }
            gameLoop();  // 开始新的游戏循环
            startDementorSpawn();
        }

        function gameOver() {
            isGameOver = true;
            gameStarted = false;
            finalScoreElement.textContent = score;
            document.getElementById('gameOver').style.display = 'flex';
            document.getElementById('difficulty').style.display = 'none';
            // 清除怪物生成定时器
            if (window.spawnInterval) {
                clearInterval(window.spawnInterval);
            }
            // 清除所有怪物元素
            clearDementors();
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);  // 取消动画帧
            }
        }

        function restart() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('difficulty').style.display = 'flex';
            // 清除所有怪物元素
            clearDementors();
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);  // 取消动画帧
            }
            lastFrameTime = 0;  // 重置帧时间
        }

        function startDementorSpawn() {
            // 清除可能存在的旧定时器
            if (window.spawnInterval) {
                clearInterval(window.spawnInterval);
            }
            
            // 设置新的定时器
            window.spawnInterval = setInterval(() => {
                if (!isGameOver && gameStarted) {
                    // 根据难度生成怪物
                    for (let i = 0; i < 2; i++) {
                        spawnDementor();
                    }
                }
            }, 1000); // 每秒生成一波
        }

        function getCanvasX(screenX) {
            const rect = canvas.getBoundingClientRect();
            const scale = GAME_WIDTH / rect.width;
            return (screenX - rect.left) * scale;
        }

        function handleMove(screenX) {
            if (!isGameOver && gameStarted) {
                const canvasX = getCanvasX(screenX);
                player.x = Math.max(player.size / 2, Math.min(GAME_WIDTH - player.size / 2, canvasX));
            }
        }

        // 触摸事件处理
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameStarted) {
                document.getElementById('difficulty').style.display = 'flex';
                startMessage.style.display = 'none';
            }
            const touch = e.touches[0];
            handleMove(touch.clientX);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleMove(touch.clientX);
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
        }, { passive: false });

        // 鼠标事件处理
        canvas.addEventListener('mousemove', (e) => {
            if (!isGameOver && gameStarted) {
                handleMove(e.clientX);
            }
        });

        canvas.addEventListener('click', (e) => {
            if (!gameStarted) {
                document.getElementById('difficulty').style.display = 'flex';
                startMessage.style.display = 'none';
            }
        });

        // 添加难度选择按钮的事件监听
        document.querySelectorAll('.difficulty-btn').forEach(button => {
            button.addEventListener('click', () => {
                startGame();
            });
        });

        restartBtn.addEventListener('click', restart);

        function spawnPowerUp(x, y) {
            powerUps.push({
                x: x,
                y: y,
                size: 20,
                speed: 5,
                emoji: '⚡'  // 闪电表示火力道具
            });
        }

        gameLoop();
    </script>
</body>

</html>